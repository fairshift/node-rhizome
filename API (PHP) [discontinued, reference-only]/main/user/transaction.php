<?php

  //As functions querying the database are called, their timestamp is stored
  //Functions that modify the database leave their full stamp
  //Functions that don't modify the database are merged by their name

 	$GLOBALS['allTransactionsLogged'] = false; //useful: gathering data for optimization

  	function transaction(){

        $input = func_get_args()[0];

        //When API call is logged
        if($input['api_call']){
        	$GLOBALS['api_call'] = http_build_query($input['api_call']);
        }

        //When function starts
        if($input['function']){
        	$keys['function'] = $input['function'];
        	if($input['route']){
        		$keys['route'] = $input['route'];
        	}
        	/*if(is_array($input['route'])){
        		$keys['route'] = ksort($input['route']);
        		print_r($input['route']);
        		if(is_array($keys['route']['language_id'])){
        			$keys['route']['language_id'] = ksort($keys['route']['language_id']);
        		}
        	}
        	if(is_array($input['dataset'])){
        		$keys['dataset'] = ksort($input['dataset']);
        	}*/
    		$transaction = json_encode($keys);
    		$GLOBALS['transactions'][$transaction][]['start'] = microtime();
        }

        //When function closes
        if($input['transaction'] && isset($GLOBALS['transactions'][$input['transaction']])){

        	//In case more than one transaction with same parameters was called...
			foreach($GLOBALS['transactions'][$input['transaction']] AS $key => $array){ 
				if(!$array['duration']){

					//Find transaction that wasn't closed yet... last to open closes first (in case of cascading functions)
					$last_start = $array['start'];
					$last_key = $key;
				}
			}
			
        	$GLOBALS['transactions'][$input['transaction']][$last_key]['duration'] = microtime() - $last_start;

        	//If data state(s) changed as compared with previous state (updateNode() measures difference)
        	if($input['statechanged']){
				/*
					if node: array('node.id' => {$node_id},  'changed');
					if table: array('{$table_name}.id => {$entry_id}'  'changed');
				*/
        		$GLOBALS['transactions'][$input['transaction']][$last_key]['statechanged'] = $input['statechanged'];
        	}

        	//In case transaction failed...
        	if(is_array($input['errors'])){
        		$GLOBALS['transactions'][$input['transaction']][$last_key]['status_code'] = $input['errors'];
        	}

        	$transaction = $input['transaction'];

        }

    	return $transaction;
  	}

  	//With blockchain, transactions and corresponding data state changes are gathered in blocks, rooted back to previous data states
  	//This is a relational database, where state changes are gathered in content_state table, and transactions logged in block table
		//To-do: merkletree implementation for data validation - script is in merkletree.php
  		//Idea for implementation: automatic post to a Facebook page with block_id and hash at random time as an independent partial blockchain storage
    function storeTransaction(){
    	$db = $GLOBALS['db'];
    	$block['user_id'] = $GLOBALS['user']['id'];
    	$block['entity_id'] = $GLOBALS['entity']['id'];

    	if(isset($GLOBALS['transactions']) && $buffer['transactions'] = $GLOBALS['transactions']){

		    //Block table in Ethereum
		    /* 
		       	- timestamp - block creation time
		       	- transaction - operation done on top of data
		       	- stateroot - links to data states in previous blocks
		       	- hash - current block hash (generated by taking into account hashes of all previous blocks - https://en.wikipedia.org/wiki/Merkle_tree#/media/File:Hash_Tree.svg)
		       	- previous_block_hash -> a sequence of blocks - data can be validated by cross-checking merkle tree proof with more than one node
		       		- !!! is this 

				* in blockchain...
					transactions can be validated by each peer, by repeating functions on top of stateroot
		    */
			//Block table in this emulation
			/*	
				- created_by_user_id - user who accessed the database
				- created_by_entity_id - user acting on behalf of an entity_id
				- entity_id - user acting on behalf of an entity_id
				- time - block creation time
				- transactions - functions with inputs
				- transactions_duration - how much time processing took (microseconds)
				- statechanged - changes made to data
				  (
					difference in getNode before and after updateNode goes into an array
		
					if node: array('node.id' => {$node_id}, $statechanged);
						hash of difference (compared node before updating / after updating)

					if table: array('{$table_name}.id => {$entry_id}', $statechanged);
						difference
				  )
				- hash - !!! to-do - merkletree hash of an array consisting of all elements listed here * previous block with statechanged hash

				* well, it's not exactly blockchain... it doesn't provide data validity check on programmatic level (though it could)
					- while transactions table can provide details into every change made (outside of block table), merkletree sequence of hashes isn't mirrored in a distributed database - thus, consensus for block validity isn't distributed among peers
					- furthermore, state changes aren't validated by each node, repeating functions on top of original data state
			*/
			
        	$GLOBALS['transactions'][$input['transaction']][$last_key]['duration'] = microtime() - $last_start;
        	$GLOBALS['transactions'][$input['transaction']][$last_key]['statechanged'] = $input['statechanged'];

			foreach($buffer['transactions'] AS $transaction => $array){

				foreach($array AS $current){

					foreach($current['statechanged'] AS $key => $changed){
						$block['statechanged'][$transaction][$transaction_start] = $changed;
					}

					if(!$GLOBALS['allTransactionsLogged']){
						if(isset($current['statechanged'])){
							$block['transactions'][$transaction] = $array;
						} else {
							$t_buffer = json_decode($transaction);
							$block['transactions']['sum'][$t_buffer->function]['duration'] = $block['transactions'][$t_buffer->function]['duration'] + $current['duration'];
							$block['transactions']['sum'][$t_buffer->function]['num_of_calls'] = $block['transactions']['sum'][$t_buffer->function]['num_of_calls'] + 1;
						}
					} else {
						$block['transactions'][$transaction] = $array;
					}
				}
			}
	    	$block['transactions_duration'] = $total_duration;

	   		$block['transactions'] = addslashes(json_encode($block['transactions']));
			$hash = md5(json_encode($block)); //!!! merkletree

			$sql = "INSERT INTO user_transaction (api_call, site_id, created_by_user_id, created_by_entity_id, time_created, transactions, transactions_duration, statechanged, hash) VALUES (".
	      							"'{$GLOBALS['api_call']}', ".
	      							"'{$GLOBALS['site']['entry_id']}', ".
	      							"'{$block['user_id']}', ".
	      							"'{$block['entity_id']}', ".
	      							time().', '.
	      							"'{$block['transactions']}', ".
	      							"'{$block['transactions_duration']}', ".
	      							"'{$block['statechanged']}', ".
	      							"'{$hash}');";

			/*if(mysqli_query($db, $sql)){
	      		unset($GLOBALS['transactions']);
			}*/

		}
    }

?>